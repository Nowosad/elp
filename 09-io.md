
# Wczytywanie i zapisywanie plików {#io}

<!-- A flat file can be a plain text file or a binary file. In the former case, the files usually contain one record per line -->
<!-- csv better than many! -->
<!-- folder roboczy -->

## Folder roboczy

Folder roboczy (ang. *working directory*) to miejsce na dysku, w którym aktualnie pracujemy.
Folder roboczy można sprawdzić korzystając z funkcji `getwd()`:


```r
getwd()
#> [1] "/home/travis/build/Nowosad/elp"
```

Zmienić folder roboczy można za pomocą skrótu *Ctrl+Shift+H* w RStudio (inaczej *Session -> Set Working Directory -> Choose Directory..*) lub też funkcji `setwd()`:


```r
setwd("home/jakub/Documents/elp/") #unix
setwd("C:/Users/jakub/Documenty/elp/") #windows
```

\BeginKnitrBlock{rmdinfo}<div class="rmdinfo">Ustawienie folderu roboczego ma też miejsce przy tworzeniu nowego lub otwieraniu istniejącego projektu RStudio.</div>\EndKnitrBlock{rmdinfo}

Folder roboczy jest ważny ponieważ pozwala na korzystanie z względnej ścieżki.
Ścieżka względna oznacza określanie ścieżki pliku w odniesieniu do istniejącego folderu roboczego, podczas, gdy ścieżka bezwzględna opisuje pełne położenie pliku.
Przykładowo, mamy plik `dane_meteo.csv`, którego pełna ścieżka to `home/jakub/Documents/elp/pliki/dane_meteo.csv`.
Z poziomu R ten plik jest widoczny zarówno jako `home/jakub/Documents/elp/pliki/dane_meteo.csv`, ale też w postaci `pliki/dane_meteo.csv`^[Jeżeli poprawnie ustawiliśmy folder roboczy.].
Używanie ścieżek względnych jest rekomendowane, ponieważ znacząco upraszcza pracę, gdy dane/obliczenia przenosi się pomiędzy różnymi komputerami lub gdy współpracuje się z innymi osobami.
Ścieżki względne są też używane w połączeniu z systemami kontroli wersji (rozdział \@ref(kontrola-wersji)).

\BeginKnitrBlock{rmdinfo}<div class="rmdinfo">Ścieżki folderów w systemach Windows są domyślnie rozdzielane ukośnikiem wstecznym (`\`, ang. *backslash*), jednak R pozwala także na użycie prawego ukośnika (`/`, ang. *slash*).
Prawy ukośnik jest rekomendowany, ponieważ działa on zarówno na Windowsach, jak i komputerach z systemami MacOS czy Linux.</div>\EndKnitrBlock{rmdinfo}

<!-- footnote with fs and here pacakges -->

## Wczytywanie plików tekstowych

Podstawowym sposobem przechowywania informacji są pliki tekstowe.
Przykładowo, mogą one przechowywać dane w postaci tabelarycznej.
Jednym z najczęściej używanych formatów tekstowych jest CSV (ang. *comma-separated values*).

Wyobraźmy sobie, że otrzymaliśmy plik tekstowy zawierający wybrane pomiary meteorologiczne dla Poznania oraz Zakopanego w roku 2017.


```
#> [1] "kod_stacji,nazwa_stacji,rok,miesiac,dzien,tavg,precip,humidity,pressure"
#> [2] "352160330,POZNAŃ,2017,1,1,1.4,0,78,1017.9"                              
#> [3] "352160330,POZNAŃ,2017,1,2,0.1,0,84,1013.1"                              
#> [4] "352160330,POZNAŃ,2017,1,3,0.5,4.8,91.1,1012.1"                          
#> [5] "352160330,POZNAŃ,2017,1,4,1.5,2.3,84.9,996.1"
```

Zapisaliśmy ten plik jako `dane_meteo.csv` w podfolderze `pliki`, więc jego ścieżka względna to `"pliki/dane_meteo.csv"`.
Po otworzeniu tego pliku w edytorze tekstu widzimy, że pierwszy jego wiersz zawiera nazwy kolumn, a następne wiersze to kolejne obserwacje.
Dodatkowo można zobaczyć, że kolumny rozdzielane są przecinkami (`,`), natomiast wartości zmiennoprzecinkowe kropkami (`.`).

Do wczytania tego pliku możemy użyć wbudowanej w R funkcji `read.csv()`, podając w niej bezwzględną lub względną ścieżkę do pliku.
W poniższych przykładzie dodatkowo ustalono argument `stringsAsFactors` na `FALSE`, dzięki czemu kolumny z tekstem nie będą zamieniane na klasę czynnikową^[Takie defensywne zachowanie może oszczędzić pewnych problemów w przyszłości.].


```r
meteo = read.csv("pliki/dane_meteo.csv", 
                 stringsAsFactors = FALSE)
str(meteo)
#> 'data.frame':	730 obs. of  9 variables:
#>  $ kod_stacji  : int  352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ...
#>  $ nazwa_stacji: chr  "POZNAŃ" "POZNAŃ" "POZNAŃ" "POZNAŃ" ...
#>  $ rok         : int  2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ...
#>  $ miesiac     : int  1 1 1 1 1 1 1 1 1 1 ...
#>  $ dzien       : int  1 2 3 4 5 6 7 8 9 10 ...
#>  $ tavg        : num  1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ...
#>  $ precip      : num  0 0 4.8 2.3 0 0 2.1 0 0 0 ...
#>  $ humidity    : num  78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ...
#>  $ pressure    : num  1018 1013 1012 996 1021 ...
```

Oprócz funkcji `read.csv()` istnieje również funkcja o nazwie `read.csv2()`. 
Pierwsza z nich jest przystosowana do wczytania danych dla których separator kolumn to `,` a separator dziesiętny to `.`, druga natomiast jest używana gdy wejściowe dane mają `;` jak separator kolumn i `,` jako separator dziesiętny.

Czasem dane tekstowe posiadają inne znaki służące jako separatory, czy też nie posiadają nazw kolumn.
W takich sytuacjach można użyć funkcji `read.table()`, która zawiera cały szereg argumentów, które można dopasować, aby poprawnie wczytać dane tekstowe.


```r
meteo = read.table("pliki/dane_meteo.csv", 
                   sep = ",",
                   header = TRUE)
str(meteo)
#> 'data.frame':	730 obs. of  9 variables:
#>  $ kod_stacji  : int  352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ...
#>  $ nazwa_stacji: Factor w/ 2 levels "POZNAŃ","ZAKOPANE": 1 1 1 1 1 1 1 1 1 1 ...
#>  $ rok         : int  2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ...
#>  $ miesiac     : int  1 1 1 1 1 1 1 1 1 1 ...
#>  $ dzien       : int  1 2 3 4 5 6 7 8 9 10 ...
#>  $ tavg        : num  1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ...
#>  $ precip      : num  0 0 4.8 2.3 0 0 2.1 0 0 0 ...
#>  $ humidity    : num  78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ...
#>  $ pressure    : num  1018 1013 1012 996 1021 ...
```

\BeginKnitrBlock{rmdinfo}<div class="rmdinfo">R posiada kilka dodatkowych funkcji pozwalających na odczytywanie plików tekstowych, tj. `read.delim()`, `read.delim2()`, `read.fwf()`, czy `readLines()`.
Funkcje `read.delim()` oraz `read.delim2()` są odpowiednikami `read.csv()` i `read.csv2()` dla plików, gdzie kolejne zmienne są oddzielane tabulatorami.
Funkcja `read.fwf()` służy do odczytywania danych o ustalonej długości kolejnych zmiennych.
Funkcja `readLines()` wczytuje kolejne linie z pliku tekstowego.
Efektem jej działania w przeciwieństwie do poprzednich funkcji nie jest ramka danych, ale wektor tekstowy, gdzie każdy kolejny element wektora to tekst z kolejnych linii.</div>\EndKnitrBlock{rmdinfo}

## Zapisywanie plików tekstowych

Plik `pliki/dane_meteo.csv` zawiera pomiary ze stacji Poznań oraz Zakopane.
W przypadku, gdy interesują nas tylko informacje dla Poznania możemy wydzielić odpowiednie wiersze używając funkcji `subset()` (sekcja \@ref(wydzielanie-df)).


```r
meteo_pzn = subset(meteo, nazwa_stacji == "POZNAŃ")
str(meteo_pzn)
#> 'data.frame':	365 obs. of  9 variables:
#>  $ kod_stacji  : int  352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ...
#>  $ nazwa_stacji: Factor w/ 2 levels "POZNAŃ","ZAKOPANE": 1 1 1 1 1 1 1 1 1 1 ...
#>  $ rok         : int  2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ...
#>  $ miesiac     : int  1 1 1 1 1 1 1 1 1 1 ...
#>  $ dzien       : int  1 2 3 4 5 6 7 8 9 10 ...
#>  $ tavg        : num  1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ...
#>  $ precip      : num  0 0 4.8 2.3 0 0 2.1 0 0 0 ...
#>  $ humidity    : num  78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ...
#>  $ pressure    : num  1018 1013 1012 996 1021 ...
```

Następnie możemy zapisać obiekt `meteo_pzn` do nowego pliku używając funkcji `write.csv()`^[Istnieje również jej odpowiednik `write.csv2()`.], poprzez podanie nazwy obiektu do zapisania oraz ścieżki zapisu wynikowego pliku.
Dodatkowo możliwe jest pominięcie zapisania nazw wierszy (`row.names = FALSE`).


```r
write.csv(meteo_pzn,
          file = "pliki/dane_meteo_pzn.csv",
          row.names = FALSE)
```

\BeginKnitrBlock{rmdinfo}<div class="rmdinfo">Funkcje `read.csv()` czy `write.csv()` są domyślnie dostępne w języku R.
Ich wydajność nie jest niestety najlepsza w przypadku plików tekstowych o dużej wielkości.
W takich przypadkach warto użyć alternatywnych funkcji, np. `read_csv()` i `write_csv()` z pakietu **readr** [@R-readr] lub `fread()` i `fwrite()` z pakietu **data.table** [@R-data.table].</div>\EndKnitrBlock{rmdinfo}

## Formaty R

<!-- info about binary -->
Formaty tekstowe są bardzo uniwersalne pozwalając na odczyt, zapis czy przenoszenie danych pomiędzy różnymi komputerami, programami czy językami programowania.
Mają one jednak pewne ograniczenia.
Wielkość pliku tekstowego rośnie bardzo szybko wraz z liczbą elementów, a plik tekstowy nie przechowuje dodatkowych informacji specyficznych dla języków programowania.
Wczytanie czy zapis dużego pliku tekstowego zabiera też relatywnie dużo czasu.

Przykładowo, chcemy aby kolumna `nazwa_stacji` była reprezentowana jako wektor czynnikowy.


```r
meteo$nazwa_stacji = as.factor(meteo$nazwa_stacji)
str(meteo)
#> 'data.frame':	730 obs. of  9 variables:
#>  $ kod_stacji  : int  352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ...
#>  $ nazwa_stacji: Factor w/ 2 levels "POZNAŃ","ZAKOPANE": 1 1 1 1 1 1 1 1 1 1 ...
#>  $ rok         : int  2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ...
#>  $ miesiac     : int  1 1 1 1 1 1 1 1 1 1 ...
#>  $ dzien       : int  1 2 3 4 5 6 7 8 9 10 ...
#>  $ tavg        : num  1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ...
#>  $ precip      : num  0 0 4.8 2.3 0 0 2.1 0 0 0 ...
#>  $ humidity    : num  78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ...
#>  $ pressure    : num  1018 1013 1012 996 1021 ...
```

W przypadku zapisania nowego obiektu do pliku tekstowego ta informacja zostanie utracona.
Alternatywnie, jeżeli chcemy używać tych danych tylko w języku R możemy zapisać je do pliku w binarnym formacie RDS. 
Taki zapis można wykonać używając funkcji `saveRDS()` podając nazwę obiektu do zapisu oraz ścieżkę do nowego pliku.


```r
saveRDS(meteo, file = "pliki/dane_meteo.rds")
```

Taki plik będzie domyślnie mniejszy (nastąpi jego kompresja przy zapisie) niż tekstowy i będzie posiadał on wszelkie informacje o klasie tego obiektu.
Ponowne wczytanie obiektu można wykonać używając funkcji `readRDS()`.


```r
meteo_rds = readRDS("pliki/dane_meteo.rds")
str(meteo_rds)
#> 'data.frame':	730 obs. of  9 variables:
#>  $ kod_stacji  : int  352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 352160330 ...
#>  $ nazwa_stacji: Factor w/ 2 levels "POZNAŃ","ZAKOPANE": 1 1 1 1 1 1 1 1 1 1 ...
#>  $ rok         : int  2017 2017 2017 2017 2017 2017 2017 2017 2017 2017 ...
#>  $ miesiac     : int  1 1 1 1 1 1 1 1 1 1 ...
#>  $ dzien       : int  1 2 3 4 5 6 7 8 9 10 ...
#>  $ tavg        : num  1.4 0.1 0.5 1.5 -3.5 -8.4 -7.9 -7.7 -5.8 -5 ...
#>  $ precip      : num  0 0 4.8 2.3 0 0 2.1 0 0 0 ...
#>  $ humidity    : num  78 84 91.1 84.9 68.3 78.6 82.5 78.5 88.6 75.3 ...
#>  $ pressure    : num  1018 1013 1012 996 1021 ...
```

Powyżej można zobaczyć, że została zachowana wcześniejsza zmiana - kolumna `nazwa_stacji` nadal jest reprezentowana poprzez wektor czynnikowy.

\BeginKnitrBlock{rmdinfo}<div class="rmdinfo">Dodatkowo możliwe jest zapisywanie wielu obiektów do jednego pliku w formacie o rozszerzeniu `.rda` a następnie ich odczytanie używając wbudowanych funkcji `save()` i `load()`.</div>\EndKnitrBlock{rmdinfo}

Pakiety to zorganizowany zbiór funkcji rozszerzający możliwości R (sekcja \@ref(pakiety)).
Istotnym elementem każdego pakietu jest jego dokumentacja, która ułatwia użytkownikom zrozumienie i wykorzystanie możliwości danego pakietu.
Często, aby pokazać szczegółowo działanie danej funkcji wykorzystywane są przykładowe dane, które można dołączyć do pakietu.

Przykładowo, wraz z R domyślnie instalowany jest pakiet o nazwie **datasets**.
Aby wyświetlić listę zbiorów danych w tym pakiecie można użyć funkcji `data()` i podać w niej nazwę konkretnego pakietu.


```r
data(package = "datasets")
```

Wczytanie zbioru danych z wybranego pakietu odbywa się poprzez wybór nazwy zbioru (np. `"faithful"`) oraz nazwy pakietu `"datasets"`.


```r
data("faithful", package = "datasets")
```

Po wykonaniu tej funkcji zbiór danych jest dostępny z poziomu R.
Zawiera on ramkę danych z dwoma kolumnami opisującymi gejzer Old Faithful (rycina \@ref(fig:faithful)): `eruptions` - czas erupcji oraz `waiting` - czas oczekiwania na kolejną erupcję.


```r
head(faithful)
#>   eruptions waiting
#> 1      3.60      79
#> 2      1.80      54
#> 3      3.33      74
#> 4      2.28      62
#> 5      4.53      85
#> 6      2.88      55
```

<div class="figure" style="text-align: center">
<img src="images/old-faithful.jpg" alt="Obraz Alberta Bierstadta przedstawiający gejzer Old Faithful około roku 1881. Źródło: [Wikipedia](https://commons.wikimedia.org/wiki/File:Bierstadt_Albert_Old_Faithful.jpg)." width="100%" />
<p class="caption">(\#fig:faithful)Obraz Alberta Bierstadta przedstawiający gejzer Old Faithful około roku 1881. Źródło: [Wikipedia](https://commons.wikimedia.org/wiki/File:Bierstadt_Albert_Old_Faithful.jpg).</p>
</div>

## Arkusze kalkulacyjne

Powszechnym sposobem przechowywania danych tabelarycznych są arkusze kalkulacyjne tworzone w programie Microsoft Excel.
Tego typu dane można wczytać do R używając pakietu **readxl** [@R-readxl].
Główną funkcją tego pakietu jest `read_excel()`, przyjmująca ścieżkę pliku do wczytania.
Dodatkowe argumenty tej funkcji pozwalają, np. na zdefiniowanie arkusza do wczytania (`sheet`) czy zasięgu komórek (`range`).


```r
library(readxl)
meteo_z_xl = read_excel("pliki/dane_meteo.xlsx")
head(meteo_z_xl)
#> # A tibble: 6 x 9
#>   kod_stacji nazwa_stacji   rok miesiac dzien  tavg precip humidity
#>        <dbl> <chr>        <dbl>   <dbl> <dbl> <dbl>  <dbl>    <dbl>
#> 1  352160330 POZNAŃ        2017       1     1   1.4    0       78  
#> 2  352160330 POZNAŃ        2017       1     2   0.1    0       84  
#> 3  352160330 POZNAŃ        2017       1     3   0.5    4.8     91.1
#> 4  352160330 POZNAŃ        2017       1     4   1.5    2.3     84.9
#> 5  352160330 POZNAŃ        2017       1     5  -3.5    0       68.3
#> 6  352160330 POZNAŃ        2017       1     6  -8.4    0       78.6
#> # … with 1 more variable: pressure <dbl>
```

Do zapisania ramki danych do formatu Excel można użyć funkcji `write_xlsx()` z pakietu **writexl** [@R-writexl]^[Po więcej informacji otwórz plik pomocy tej funkcji `?write_xlsx()`.].



<!-- block problemy z excelem jak daty -->

## Inne formaty

Powyżej można było zobaczyć jaki sposób można wczytać dane z różnorodnych plików tekstowych, R, czy arkuszy kalkulacyjnych.
R pozwala jednocześnie na otworzenie wielu innych formatów plików używając dodatkowych pakietów.
Przykładowo, hierarchiczne formaty danych można wczytać używając pakietu **jsonline** (format `.json`) [@R-jsonlite] czy **xml2** (format `.xml`) [@R-xml2], a formaty danych przestrzennych używając pakietu **sf** (dane wektorowe) [@R-sf] czy **raster** (dane rastrowe) [@R-raster].
Zestawienie zawierające dodatkowe przykłady można znaleźć pod adresem https://github.com/leeper/rio.

Powszechną sytuacją jest przechowywanie danych w różnego rodzaju bazach danych.
Ma to miejsce, kiedy dane są znacznej wielkości, mają złożone relacje, czy też muszą być jednocześnie dostępne dla wielu osób.
Dostęp do baz danych w R możliwy jest używając pakietu **DBI** [@R-DBI] wraz z dodatkowym pakietem dla konkretnego systemu bazodanowego (np. **RPostgreSQL** dla baz PostgreSQL [@R-RPostgreSQL] czy **RSQLite** dla baz SQLite [@R-RSQLite]). ^[Więcej informacji o łączeniu się z bazami danych można znaleść na stronie https://db.rstudio.com/getting-started/connect-to-database.]

## Dane internetowe

Pliki, które chcemy otworzyć nie muszą od razu znajdować się na dysku naszego komputera.
Możliwe jest, między innymi, pobranie ich z poziomu R za pomocą funkcji `download.file()`^[Funkcje takie jak `read.csv()` pozwalają na otworzenie pliku tekstowego bezpośrednio z adresu internetowego.].
Należy w niej podać adres URL pliku do pobrania, oraz nazwę pliku do zapisania.


```r
download.file("https://raw.githubusercontent.com/Nowosad/elp/master/pliki/dane_meteo.csv", 
              destfile = "pliki/dane_meteo_url.csv")
```

W efekcie plik `dane_meteo_url.csv` zostanie zapisany w folderze `pliki`.
Funkcja `download.file()` ma też szereg dodatkowych argumentów, między innymi `method` określającą metodę pobierania danych oraz `mode` określający sposób zapisu pliku.

## Działania na plikach i folderach

Z poziomu R możliwe jest również zarządzanie folderami i plikami na dysku.
Do tworzenia nowych folderów służy funkcja `dir.create()`, np. `dir.create("dane")` stworzy nowy podfolder o nazwie `"dane"`.
Sprawdzenie czy folder już istnieje możliwe jest używając funkcji `dir.exists()`, np. `dir.exists("dane")`, która zwraca wartość `TRUE` gdy folder o tej nazwie istnieje lub `FALSE` gdy takiego folderu nie ma.
Do usuwania istniejących folderów służy funkcja `unlink()`.
W jej przypadku konieczne jest podanie, oprócz nazwy folder do usunięcia, argumentu `recursive = TRUE`.
Przykładowo, aby usunąć folder `"dane"` należy wpisać `unlink("dane", recursive = TRUE)`.

Sprawdzenie czy plik istnieje na dysku można wykonać używając `file.exist()`, a usunąć go za pomocą `file.remove()`.
Obie funkcje przyjmują jako wejście wektor znakowy zawierający nazwy plików do sprawdzenia czy usunięcia.

W przypadkach, gdy konieczne jest stworzenie nowego archiwum ZIP lub rozpakowanie istniejącego pliku w tym formacie można użyć funkcji `zip()` oraz `unzip()`^[Na komputerach z systemem Windows wymagane jest posiadanie zainstalowanego programu do rozpakowywania plików ZIP.].

## Zadania

<!-- wczytaj jeden format, zapisz inny -->
<!-- automatycznie wczytaj dwa pliki -->
<!-- wczytaj, zamien, zapisz -->
<!-- napisz funkcje do zamiany -->
<!-- pobierz, zamien, zapisz, usun stary plik -->
